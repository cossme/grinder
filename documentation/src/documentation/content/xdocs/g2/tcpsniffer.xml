<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>The TCPSniffer</title>
  </header>
<body>
    <p>The TCPSniffer is misnamed: its not a sniffer (like
    <code>snoop</code> or <em>Ethereal</em>) at all, but rather a
    <em>proxy</em> that you can place between in a TCP stream. It
    filters the request and response streams, sending the results to
    <code>stdout</code>. You can control its behaviour by specifying
    different filters. Whilst the TCPSniffer is very useful in its own
    right, its main purpose as far as The Grinder goes is to
    automatically generate scripts for the HTTP plugin.</p>

    <note>If you are not interested in the ability to record scripts
    for The Grinder 2, use the The Grinder 3's <a
    href="site:g3/tcpproxy">TCPProxy</a> instead. It has more features
    and fixes.</note>

    <section>
      <title>Starting the TCPSniffer</title>

      <p>You invoke the TCPSniffer with something like:</p>

<source class="sh">
CLASSPATH=/opt/grinder/lib/grinder.jar
export CLASSPATH

java net.grinder.TCPSniffer
</source>

      <p>Say <code>java net.grinder.TCPSniffer -?</code> to get a list
      of the command line options.</p>

      <p>Suppose you want to capture a conversation with a server on
      host <em>server</em>, port <em>7001</em>, you should say
      something like:</p>

<source class="sh">
java net.grinder.TCPSniffer -remoteHost server
</source>

      <p>The TCPSniffer will start and display the following
      information:</p>

<source class="jython"> class="text">
Initialising standard sniffer engine with the parameters:
   Request filter:  net.grinder.tools.tcpsniffer.EchoFilter
   Response filter: net.grinder.tools.tcpsniffer.EchoFilter
   Local host:       localhost
   Local port:       8001
   Remote host:      localhost
   Remote port:      7001
Engine initialised, listening on port 8001
</source>

      <p>You can then point your web browser at
      <code>http://localhost:8001/</code> and exercise the application
      through the browser. The TCPSniffer will echo your requests to
      the terminal and forward the requests to
      <code>localhost:7001</code>, as well as echoing response from
      the server the terminal and returning them to the browser.</p>
    </section>

    <section id="http-proxy">
      <title>Using the TCPSniffer as an HTTP proxy</title>

      <p>One problem of running the TCPSniffer as described above is
      that it only forwards to a single remote host. Any links or
      redirects to other hosts that the application returns to the
      browser will bypass the TCPSniffer, meaning that they will not
      feature in the test script. This also applies to absolute URLs
      to the server.</p>

      <p>When recording browser traffic, a much better way to use the
      TCPSniffer is to run it as an HTTP proxy:</p>

<source class="sh">
java net.grinder.TCPSniffer -proxy
</source>

      <p>This will make it listen as an HTTP proxy on port
      <code>8001</code> (the default, you can change it with
      <code>-localPort</code>), and forward requests onto the relevant
      remote host, while echoing out the HTTP interactions.</p>

      <p>You should set your browser connection settings to specify
      the TCP sniffer as the HTTP proxy (set <em>host</em> to be the
      host on which the TCPSniffer is running and <em>port></em> to be
      <code>8001</code>). You then use your browser as normal, e.g. in
      the example in the previous section you should use the direct
      address <code>http://localhost:7001</code> in your browser.</p>

      <p>The TCPSniffer will run as a proxy for both HTTP and HTTPS if
      you specify <code>-ssl</code>.</p>
    </section>

    <section id="HttpPluginSnifferFilter">
      <title>Using the HttpPluginSnifferFilter</title>

      <p>You can use the TCPSniffer to generate an HTTP plugin script
      segment suitable for use with The Grinder.</p>

<source class="sh">
java net.grinder.TCPSniffer -proxy -httpPluginFilter
</source>

      <p>The output of the HttpPluginSnifferFilter looks like:</p>

<source class="text">
Initialising standard sniffer engine with the parameters:
   Request filter: net.grinder.plugin.http.HttpPluginSnifferFilter
   Response filter: net.grinder.tools.tcpsniffer.NullFilter
   Local host:       localhost
   Local port:       8001
   Listening as an HTTP proxy
   Engine initialised, listening on port 8001

  #
  # The Grinder version 2.8.3
  #
  # Script generated by the TCPSniffer at 25-Apr-02 08:17:57
  #

  grinder.processes=1
  grinder.threads=1
  grinder.cycles=0

  grinder.test0.sleepTime=11336
  grinder.test0.parameter.url=http://localhost:7001/
  grinder.test1.sleepTime=12168
  grinder.test1.parameter.url=http://localhost:7001/lah.html
  grinder.test2.sleepTime=411
  grinder.test2.parameter.url=http://localhost:7001/test.gif
  grinder.test3.sleepTime=4786
  grinder.test3.parameter.url=http://localhost:7001/lah.html
  grinder.test3.parameter.header.If-Modified-Since=Tue, 16 Jan 2001 16:26:42 GMT
  grinder.test4.sleepTime=311
  grinder.test4.parameter.url=http://localhost:7001/test.gif
  grinder.test4.parameter.header.If-Modified-Since=Mon, 06 Nov 2000 08:35:58 GMT
</source>

      <p>The script part of this is sent to the <code>stdout</code>
      stream, whereas the information messages are sent to
      <code>stderr</code>. You can redirect the script part to a file
      if you wish:</p>

<source class="sh">
java net.grinder.TCPSniffer -proxy -httpPluginFilter &gt; grinder.properties
</source>

      <p>You can then use this file with The Grinder.</p>
    </section>

    <section>
      <title>SSL and HTTPS support</title>

      <p>The TCPSniffer has SSL support. If you are using an old JVM,
      (earlier than Java SE 1.4.1) you must first install <a
      href="ext:oracle/java/jsse-archive">the JSSE</a>.</p>

      <p>SSL relationships are necessarily point to point. When you
      interpose the TCPSniffer you end up with:</p>

      <p class="quote">Client &lt;--- ssl1 ---&gt; TCPSniffer &lt;---
      ssl2 ---&gt; Server</p>

      <p>Where <em>ssl1</em> and <em>ssl2</em> are two separate SSL
      connections. Each SSL connection has its own set of client and
      server certificates (both of which are optional).</p>

      <p>The TCPSniffer will negotiate appropriate certificates for
      both connections using certificates specified in a key store.
      See the JSSE documentation for how to set up a key store. There
      are three parameters you can pass as command line options to the
      TCPSniffer to specify key store details:</p>

      <table>
	<tr>
	  <td><code>-keyStore</code> <em>file</em></td>
	  <td>The key store file.</td>
	</tr>
	<tr>
	  <td><code>-keyStorePassword</code> <em>password</em></td>
	  <td>The password for the key store.</td>
	</tr>
	<tr>
	  <td><code>-keyStoreType</code> <em>type</em></td>
	  <td>The type, defaults to <code>jks</code>.</td>
	</tr>
      </table>

      <p>You can also specify these with the corresponding
      <code>javax.net.ssl.XXX</code> properties.</p>

      <p>Here's an example of starting the TCPSniffer as an HTTP/HTTPS
      proxy using the <em>testkeys</em> key store provided with the
      JSSE samples:</p>

<source class="sh">
java net.grinder.TCPSniffer -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</source>

      <p>Even if you are not using client certificates, you probably
      need to specify a key store. This is because the proxy needs a
      server certificate of its own:</p>

      <p class="quote">Browser -----&gt; [ServerCert] Proxy ----&gt;
      [ServerCert2] Target</p>

      <p>You need to start the proxy with a key store containing a
      self-signed server certificate. This is the certificate that the
      browser will be presented with. If you fail to provide a server
      certificate, you will get a <em>No available certificate
      corresponds to the SSL cipher suites which are enabled</em>
      exception. The easiest way to provide a certificate is to copy
      the <em>testkeys</em> file from the JSSE samples distribution
      and start the sniffer using:</p>

<source class="sh">
java net.grinder.TCPSniffer -ssl -proxy -keyStore testkeys -keyStorePassword passphrase
</source>

      <p>Alternatively you might want to generate your own. Here's an
      example:</p>

<source class="text">
  PASTON:philipa% keytool -genkey -keystore testkeys -storepass passphrase -keyalg rsa
  What is your first and last name?
    [Unknown]:  localhost
  What is the name of your organizational unit?
    [Unknown]:  Engineering
  What is the name of your organization?
    [Unknown]:  Grinders Inc
  What is the name of your City or Locality?
    [Unknown]:  Grindsville
  What is the name of your State or Province?
    [Unknown]:  Grindshire
  What is the two-letter country code for this unit?
    [Unknown]:  GR
  Is &lt;CN=localhost, OU=Engineering, O=Grinders Inc, L=Grindsville, ST=Grindshire, C=GR%gt; correct?
    [no]:  yes

  Enter key password for &lt;mykey&gt;
          (RETURN if same as keystore password):
  PASTON:philipa%
</source>

      <p>The <em>first and last name</em> ought to match the server
      which you run the proxy on, and you must specify <code>-keyalg
      rsa</code> to generate a certificate that works with common
      browsers. See the <code>keytool</code> notes in the JDK
      documentation for how to do more tricks.</p>

      <p>You may find <code>NullPointerException</code>s when using
      PKCS12 files generated by some tools, e.g. <code>openssl</code>.
      Use the Java <code>keytool</code> utility to maintain key stores
      and you'll be all right.</p>
    </section>

    <section>
      <title>The Sniff 'n' Grind web application</title>

      <p><em>Sniff 'n; Grind</em> is Paddy Spencer's J2EE web
      application that automates the tasks involved using the
      TCPSniffer to record and replay HTTPPlugin scripts. This section
      contains rather minimal notes on its use.</p>

      <section>
	<title>Setup page</title>

	<p>In the setup page enter the starting URL; this is usually
	the front page of the application you're testing. You need to
	include the protocol in the URL, only HTTP and HTTPS are
	currently supported. Click on the button to go to...</p>
      </section>

      <section>
	<title>Start TCPSniffer page</title>

	<p>This page tells you what you need to change your browser
	proxy settings to. You need to so this before clicking on the
	link to start the page, otherwise your requests will go
	through the proxy you normally use and the sniffer won't pick
	them up. Once you've set the proxy, click on the <em>Click
	here to go to...</em> link, and the start URL will be returned
	in a new window.</p>

	<p>If you specify a certificate in the <code>web.xml</code>
	file, and a secure starting URL (an HTTPS rather than HTTP
	one) then the web application will let you sniff and grind
	your ssl-using web application. The only difference you'll
	notice is that you will be asked to accept an untrusted
	certificate from the server. This is because the web
	application uses the certificate you give it as a server
	certificate when you connect to it and as a client certificate
	when it connects to your web application. So you'd better make
	sure that it's one your app will accept!</p>

	<p><em>Do not close the sniffer window.</em> If you do that
	you will not be able to end the test and get your results.</p>

	<p>In order not to be a resource hog, the sniffer proxy
	process will timeout after a given number of seconds
	(configurable via the <code>web.xml</code>), so if you don't
	do anything for a while, you may find your proxy isn't there
	any more.</p>

	<p>When you've finished the test, close the test window and
	rest your browser proxy to it's original settings (you DID
	note down those settings, didn't you?) and then click on the
	<em>stop</em> button. You will be taken to...</p>
      </section>

      <section>
	<title>TCPSniffer results page</title>

	<p>The Sniff 'n' Grind generates a number of files. As a
	minimum there are two:</p>

	<ul>
	  <li><code>httpsniffer.err</code> - which contains the
	  initial startup information as well as any runtime errors
	  that might have occurred.</li>

	  <li><code>httpsniffer.out</code> - which contains the
	  details of the test(s).</li>
	</ul>

	<p>If you wish to run the test manually, you need to copy
	these into your <code>grinder.properties</code> file and run
	The Grinder in the normal way. You will also need to cut and
	paste the various <code>http-plugin-sniffer-post</code> files,
	if any.</p>

	<p>If you instead want to run The Grinder right now, with your
	recorded results, then click on the link and go to...</p>
      </section>

      <section>
	<title>The Grinder setup page</title>

	<p>Despite, or perhaps because of, the vast, bewildering array
	of properties  that can be  set to  control a Grinder session,
	the web application  (in its current  incarnation) only allows
	you to  set the numbers  of processes, threads and cycles from
	within  the browser. These  default  to one  of each and  have
	maximum  settings  (currently hard-coded)  of  5 processes, 25
	threads and 50 cycles.</p>

	<p>The <em>reset</em> button resets the values in the form (as
	you'd expect) and <em>Grind me, baby!</em> does what it says,
	leading to...</p>
      </section>

      <section>
	<title>Wait page</title>

	<p>The patience page. If I was a real <code>31337 h4x0r
	d00d</code> I'd have written some kewl applet which would keep
	you entertained with graphical and highly amusing pr0n
	animations to keep you entertained while sneakily querying the
	server for whether The Grinder has finished. However, I'm not
	and so you've got a rather dull page with a five second
	refresh on it and a note saying, "Wait."</p>
      </section>

      <section>
	<title>The Grinder results page</title>

	<p>The results page simply presents the contents of the files
	in the <code>log</code> directory (so if you've used some huge
	number of threads and cycles, this page will be BIG) and gives
	you the options to re-run the grinder against the same test,
	but with different properties, or to record another test.</p>
      </section>
    </section>
  </body>
</document>
